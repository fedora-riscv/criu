From 7168eac9043df54efba6a892ae4e1578ebb9c5c8 Mon Sep 17 00:00:00 2001
From: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
Date: Tue, 3 Aug 2021 13:05:32 +0300
Subject: [PATCH 035/245] zdtm: make sock_opts02 also check lock change by
 SO_*BUF*

Reviewed-by: Alexander Mikhalitsyn <alexander.mikhalitsyn@virtuozzo.com>
Signed-off-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
---
 test/zdtm/static/sock_opts02.c | 63 +++++++++++++++++++++++++++++-----
 1 file changed, 54 insertions(+), 9 deletions(-)

diff --git a/test/zdtm/static/sock_opts02.c b/test/zdtm/static/sock_opts02.c
index 21a81a28f..7ea98744a 100644
--- a/test/zdtm/static/sock_opts02.c
+++ b/test/zdtm/static/sock_opts02.c
@@ -13,32 +13,77 @@ const char *test_author = "Pavel Tikhomirov <ptikhomirov@virtuozzo.com>";
 #define SO_BUF_LOCK 72
 #endif
 
-#define NSOCK 4
+#ifndef SOCK_SNDBUF_LOCK
+#define SOCK_SNDBUF_LOCK 1
+#endif
+#ifndef SOCK_RCVBUF_LOCK
+#define SOCK_RCVBUF_LOCK 2
+#endif
+
+#define BUFSIZE 16384
+
+struct sk_opt {
+	int type;
+	uint32_t val;
+	uint32_t lock;
+} sk_opts[] = { { SO_BUF_LOCK, 0, 0 },
+		{ SO_BUF_LOCK, SOCK_SNDBUF_LOCK, SOCK_SNDBUF_LOCK },
+		{ SO_BUF_LOCK, SOCK_RCVBUF_LOCK, SOCK_RCVBUF_LOCK },
+		{ SO_BUF_LOCK, SOCK_SNDBUF_LOCK | SOCK_RCVBUF_LOCK, SOCK_SNDBUF_LOCK | SOCK_RCVBUF_LOCK },
+		{ SO_SNDBUF, BUFSIZE, SOCK_SNDBUF_LOCK },
+		{ SO_RCVBUF, BUFSIZE, SOCK_RCVBUF_LOCK } };
+
+#define NSOCK ARRAY_SIZE(sk_opts)
+
+char *type_to_str(int type)
+{
+	switch (type) {
+	case SO_BUF_LOCK:
+		return "SO_BUF_LOCK";
+	case SO_SNDBUFFORCE:
+		return "SO_SNDBUFFORCE";
+	case SO_RCVBUFFORCE:
+		return "SO_RCVBUFFORCE";
+	}
+	return NULL;
+}
 
 int main(int argc, char **argv)
 {
 	int sock[NSOCK];
-	uint32_t val[NSOCK];
 	int ret, i;
 	int exit_code = 1;
 
 	test_init(argc, argv);
 
-	for (i = 0; i < NSOCK; i++) {
+	for (i = 0; i < NSOCK; i++)
 		sock[i] = -1;
-		val[i] = i;
-	}
 
 	for (i = 0; i < NSOCK; i++) {
+		uint32_t tmp;
+		socklen_t len;
+
 		sock[i] = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
 		if (sock[i] < 0) {
 			pr_perror("can't create socket %d", i);
 			goto err;
 		}
 
-		ret = setsockopt(sock[i], SOL_SOCKET, SO_BUF_LOCK, &val[i], sizeof(val[i]));
+		ret = setsockopt(sock[i], SOL_SOCKET, sk_opts[i].type, &sk_opts[i].val, sizeof(sk_opts[i].val));
+		if (ret < 0) {
+			pr_perror("can't set %s (%u) on socket %d", type_to_str(sk_opts[i].type), sk_opts[i].val, i);
+			goto err;
+		}
+
+		len = sizeof(tmp);
+		ret = getsockopt(sock[i], SOL_SOCKET, SO_BUF_LOCK, &tmp, &len);
 		if (ret < 0) {
-			pr_perror("can't set SO_BUF_LOCK (%u) on socket %d", val[i], i);
+			pr_perror("can't get SO_BUF_LOCK from socket %d", i);
+			goto err;
+		}
+
+		if (tmp != sk_opts[i].lock) {
+			fail("SO_BUF_LOCK missmatch %u != %u", tmp, sk_opts[i].lock);
 			goto err;
 		}
 	}
@@ -57,8 +102,8 @@ int main(int argc, char **argv)
 			goto err;
 		}
 
-		if (tmp != val[i]) {
-			fail("SO_BUF_LOCK missmatch %u != %u", tmp, val[i]);
+		if (tmp != sk_opts[i].lock) {
+			fail("SO_BUF_LOCK missmatch %u != %u", tmp, sk_opts[i].lock);
 			goto err;
 		}
 	}
-- 
2.35.1

