From 0cba2304c4796cda832d6e0b16ef2dc305fb6a13 Mon Sep 17 00:00:00 2001
From: Bui Quang Minh <minhquangbui99@gmail.com>
Date: Wed, 15 Dec 2021 23:03:29 +0700
Subject: [PATCH 126/249] proc_parse, files: Add support for hugetlb memory
 mapping

When memfd can be used with hugetlb, we use memfd for checkpoint/restore
anonymous shared memory. Otherwise, map_files symlinks is used for
checkpoint/restore anonymous shared memory.

Signed-off-by: Bui Quang Minh <minhquangbui99@gmail.com>
---
 criu/files.c      |  3 ++-
 criu/proc_parse.c | 38 +++++++++++++++++++++++++++++++-------
 2 files changed, 33 insertions(+), 8 deletions(-)

diff --git a/criu/files.c b/criu/files.c
index 429493ccb..7f4b90086 100644
--- a/criu/files.c
+++ b/criu/files.c
@@ -548,7 +548,8 @@ static int dump_one_file(struct pid *pid, int fd, int lfd, struct fd_opts *opts,
 
 		p.link = &link;
 
-		if (is_memfd(p.stat.st_dev))
+		/* TODO: Dump for hugetlb fd when memfd hugetlb is not supported */
+		if (is_memfd(p.stat.st_dev) || (kdat.has_memfd_hugetlb && is_hugetlb_dev(p.stat.st_dev, NULL)))
 			ops = &memfd_dump_ops;
 		else if (link.name[1] == '/')
 			ops = &regfile_dump_ops;
diff --git a/criu/proc_parse.c b/criu/proc_parse.c
index eb3efc877..9009b96f7 100644
--- a/criu/proc_parse.c
+++ b/criu/proc_parse.c
@@ -41,6 +41,7 @@
 #include "path.h"
 #include "fault-injection.h"
 #include "memfd.h"
+#include "hugetlb.h"
 
 #include "protobuf.h"
 #include "images/fdinfo.pb-c.h"
@@ -259,7 +260,7 @@ static int vma_stat(struct vma_area *vma, int fd)
 static int vma_get_mapfile_user(const char *fname, struct vma_area *vma, struct vma_file_info *vfi, int *vm_file_fd,
 				const char *path)
 {
-	int fd;
+	int fd, hugetlb_flag = 0;
 	dev_t vfi_dev;
 
 	/*
@@ -316,17 +317,19 @@ static int vma_get_mapfile_user(const char *fname, struct vma_area *vma, struct
 		return -1;
 	}
 
-	if (is_anon_shmem_map(vfi_dev)) {
+	if (is_hugetlb_dev(vfi_dev, &hugetlb_flag) || is_anon_shmem_map(vfi_dev)) {
 		if (!(vma->e->flags & MAP_SHARED))
-			return -1;
+			vma->e->status |= VMA_ANON_PRIVATE;
+		else
+			vma->e->status |= VMA_ANON_SHARED;
 
 		vma->e->flags |= MAP_ANONYMOUS;
-		vma->e->status |= VMA_ANON_SHARED;
 		vma->e->shmid = vfi->ino;
+		vma->e->flags |= hugetlb_flag;
 
 		if (!strncmp(fname, "/SYSV", 5)) {
 			vma->e->status |= VMA_AREA_SYSVIPC;
-		} else {
+		} else if (vma->e->flags & MAP_SHARED) {
 			if (fault_injected(FI_HUGE_ANON_SHMEM_ID))
 				vma->e->shmid += FI_HUGE_ANON_SHMEM_ID_BASE;
 		}
@@ -576,6 +579,7 @@ static int handle_vma(pid_t pid, struct vma_area *vma_area, const char *file_pat
 		}
 	} else if (*vm_file_fd >= 0) {
 		struct stat *st_buf = vma_area->vmst;
+		int hugetlb_flag = 0;
 
 		if (S_ISREG(st_buf->st_mode))
 			/* regular file mapping -- supported */;
@@ -586,7 +590,8 @@ static int handle_vma(pid_t pid, struct vma_area *vma_area, const char *file_pat
 			goto err;
 		}
 
-		if (is_anon_shmem_map(st_buf->st_dev) && !strncmp(file_path, "/SYSV", 5)) {
+		if ((is_anon_shmem_map(st_buf->st_dev) || is_hugetlb_dev(st_buf->st_dev, NULL)) &&
+		    !strncmp(file_path, "/SYSV", 5)) {
 			vma_area->e->flags |= MAP_ANONYMOUS;
 			vma_area->e->status |= VMA_ANON_SHARED;
 			vma_area->e->shmid = st_buf->st_ino;
@@ -595,10 +600,29 @@ static int handle_vma(pid_t pid, struct vma_area *vma_area, const char *file_pat
 			pr_info("path: %s\n", file_path);
 			vma_area->e->status |= VMA_AREA_SYSVIPC;
 		} else {
-			if (is_anon_shmem_map(st_buf->st_dev)) {
+			/* Dump shmem dev, hugetlb dev (private and share) mappings the same way as memfd
+			 * when possible.
+			 */
+			if (is_memfd(st_buf->st_dev) || is_anon_shmem_map(st_buf->st_dev) ||
+			    (kdat.has_memfd_hugetlb && is_hugetlb_dev(st_buf->st_dev, &hugetlb_flag))) {
 				vma_area->e->status |= VMA_AREA_MEMFD;
+				vma_area->e->flags |= hugetlb_flag;
 				if (fault_injected(FI_HUGE_ANON_SHMEM_ID))
 					vma_area->e->shmid += FI_HUGE_ANON_SHMEM_ID_BASE;
+			} else if (is_hugetlb_dev(st_buf->st_dev, &hugetlb_flag)) {
+				/* hugetlb mapping but memfd does not support HUGETLB */
+				vma_area->e->flags |= hugetlb_flag;
+				vma_area->e->flags |= MAP_ANONYMOUS;
+
+				if (vma_area->e->flags & MAP_SHARED) {
+					vma_area->e->status |= VMA_ANON_SHARED;
+					vma_area->e->shmid = st_buf->st_ino;
+				} else {
+					vma_area->e->status |= VMA_ANON_PRIVATE;
+				}
+
+				close_safe(vm_file_fd);
+				return 0;
 			}
 
 			if (vma_area->e->flags & MAP_PRIVATE)
-- 
2.35.1

