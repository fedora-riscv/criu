From 0279af775209d9c77cac457deaf927e2a14be126 Mon Sep 17 00:00:00 2001
From: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
Date: Wed, 18 Dec 2019 13:45:22 +0300
Subject: [PATCH 164/249] mount: split mnt_is_external(_bind) and
 can_receive_master_from_external

We use mnt_is_external():

1) In validate_mounts() to skip fsroot existence check for mounts which
will be bind-mounted from external mounts.

2) In resolve_shared_mounts() to skip error on slave mounts without
master mount, if they can receive these master_id through external
mount.

3) In dump_one_fs to skip dump of mounts which will be bind-mounted from
external mounts.

Cases (1) and (3) are the same, but case (2) is quiet different. Lets
split these cases thus making things simplier.

Effectively these patch does not change criu's behaviour at all. While
I can't say that old mnt_is_external was wrong, it was too complex and
hard for understanding, so it's worth to switch to lookup across
bindmounts list via general mnt_bind_pick() helper. And now when it is
obvious that mnt_is_external looks for external bindmount, let's also
change it's name to mnt_is_external_bind.

Cherry-picked from Virtuozzo criu:
https://src.openvz.org/projects/OVZ/repos/criu/commits/494b52ba8

Changes: use mnt_bind_pick helper, use is_sub_path helper to be more
robust, rename mnt_is_external to mnt_is_external_bind, fix
clang-format, export to mount.h, use mnt_is_nodev_external as we can not
inherit master from device-external mounts.

Signed-off-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
---
 criu/include/mount.h |  2 ++
 criu/mount.c         | 57 ++++++++++++++++++++------------------------
 2 files changed, 28 insertions(+), 31 deletions(-)

diff --git a/criu/include/mount.h b/criu/include/mount.h
index c782d84bb..b21c23975 100644
--- a/criu/include/mount.h
+++ b/criu/include/mount.h
@@ -173,6 +173,8 @@ extern int remount_readonly_mounts(void);
 extern int try_remount_writable(struct mount_info *mi, bool ns);
 extern bool mnt_is_overmounted(struct mount_info *mi);
 
+extern bool mnt_is_external_bind(struct mount_info *mi);
+
 extern struct mount_info *mnt_bind_pick(struct mount_info *mi,
 					bool (*pick)(struct mount_info *mi, struct mount_info *bind));
 #endif /* __CR_MOUNT_H__ */
diff --git a/criu/mount.c b/criu/mount.c
index fcdf06d50..ef50d0fa2 100644
--- a/criu/mount.c
+++ b/criu/mount.c
@@ -552,39 +552,34 @@ static bool mnt_needs_remap(struct mount_info *m)
 	return false;
 }
 
-/*
- * Say mount is external if it was explicitly specified as an
- * external or it will be bind from such an explicit external
- * mount, we set bind in propagate_mount and propagate_siblings
- */
-
-static bool mnt_is_external(struct mount_info *m)
+static bool __mnt_is_external_bind(struct mount_info *mi, struct mount_info *bind)
 {
-	struct mount_info *t;
-
-	while (m) {
-		if (m->external)
-			return 1;
+	if (bind->external && is_sub_path(mi->root, bind->root))
+		return true;
 
-		if (!list_empty(&m->mnt_share))
-			list_for_each_entry(t, &m->mnt_share, mnt_share)
-				if (t->external)
-					return 1;
+	return false;
+}
 
-		/*
-		 * Shouldn't use mnt_bind list before it was populated in search_bindmounts
-		 */
-		BUG_ON(!m->mnt_bind_is_populated);
+/*
+ * Say mount is external if it was explicitly specified as an external or it
+ * can be bind-mounted from such an explicit external mount.
+ */
+bool mnt_is_external_bind(struct mount_info *mi)
+{
+	return mnt_bind_pick(mi, __mnt_is_external_bind);
+}
 
-		if (m->master_id <= 0 && !list_empty(&m->mnt_bind))
-			list_for_each_entry(t, &m->mnt_bind, mnt_bind)
-				if (issubpath(m->root, t->root) && t->external)
-					return 1;
+static bool __can_receive_master_from_external(struct mount_info *mi, struct mount_info *bind)
+{
+	if (mnt_is_nodev_external(bind) && bind->master_id == mi->master_id && is_sub_path(mi->root, bind->root))
+		return true;
 
-		m = m->mnt_master;
-	}
+	return false;
+}
 
-	return 0;
+static struct mount_info *can_receive_master_from_external(struct mount_info *mi)
+{
+	return mnt_bind_pick(mi, __can_receive_master_from_external);
 }
 
 /*
@@ -627,7 +622,7 @@ static int validate_mounts(struct mount_info *info, bool for_dump)
 		if (validate_children_collision(m))
 			return -1;
 
-		if (mnt_is_external(m))
+		if (mnt_is_external_bind(m))
 			continue;
 
 		/*
@@ -1001,7 +996,7 @@ static int resolve_shared_mounts(struct mount_info *info, int root_master_id)
 		 * If we haven't already determined this mount is external,
 		 * or bind of external, then we don't know where it came from.
 		 */
-		if (need_master && m->parent && !mnt_is_external(m)) {
+		if (need_master && m->parent && !can_receive_master_from_external(m)) {
 			pr_err("Mount %d %s (master_id: %d shared_id: %d) "
 			       "has unreachable sharing. Try --enable-external-masters.\n",
 			       m->mnt_id, m->mountpoint, m->master_id, m->shared_id);
@@ -1640,7 +1635,7 @@ static int dump_one_fs(struct mount_info *mi)
 	struct mount_info *t;
 	bool first = true;
 
-	if (mi->is_ns_root || mi->need_plugin || mnt_is_external(mi) || !mi->fstype->dump)
+	if (mi->is_ns_root || mi->need_plugin || mnt_is_external_bind(mi) || !mi->fstype->dump)
 		return 0;
 
 	/* mnt_bind is a cycled list, so list_for_each can't be used here. */
@@ -2925,7 +2920,7 @@ static int get_mp_root(MntEntry *me, struct mount_info *mi)
 		me->ext_key = me->root;
 		/*
 		 * Putting the id of external mount which is provided by user,
-		 * to ->root can confuse mnt_is_external and other functions
+		 * to ->root can confuse mnt_is_external_bind and other functions
 		 * which expect to see the path in the file system to the root
 		 * of these mount (mounts_equal, mnt_build_ids_tree,
 		 * find_fsroot_mount_for, find_best_external_match, etc.)
-- 
2.35.1

