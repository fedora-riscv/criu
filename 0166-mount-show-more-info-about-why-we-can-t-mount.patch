From 43ff6e839fd1a7802075193b1534cc4ae1ea96fb Mon Sep 17 00:00:00 2001
From: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
Date: Thu, 12 Sep 2019 10:10:37 +0300
Subject: [PATCH 166/249] mount: show more info about why we can't mount

Currently if we have mount deadlock it is hard to understand which
mounts lock each other, these makes it easier.

Cherry-picked from Virtuozzo criu:
https://src.openvz.org/projects/OVZ/repos/criu/commits/8ba8499e2
Cherry-picked from Virtuozzo criu:
https://src.openvz.org/projects/OVZ/repos/criu/commits/48d044ae11

Changes: merge newline fixup.

Signed-off-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
---
 criu/mount.c | 42 ++++++++++++++++++++++++++++++++----------
 1 file changed, 32 insertions(+), 10 deletions(-)

diff --git a/criu/mount.c b/criu/mount.c
index 844f52e4d..f1c970da6 100644
--- a/criu/mount.c
+++ b/criu/mount.c
@@ -2426,8 +2426,10 @@ static bool rst_mnt_is_root(struct mount_info *m)
 
 static bool can_mount_now(struct mount_info *mi)
 {
-	if (rst_mnt_is_root(mi))
+	if (rst_mnt_is_root(mi)) {
+		pr_debug("%s: true as %d is mntns root\n", __func__, mi->mnt_id);
 		return true;
+	}
 
 	/* Parent should be mounted already, that's how mnt_tree_for_each works */
 	BUG_ON(mi->parent && !mi->parent->mounted);
@@ -2444,21 +2446,35 @@ static bool can_mount_now(struct mount_info *mi)
 	if (mi->mnt_master) {
 		struct mount_info *c, *s;
 
-		if (mi->bind == NULL)
+		if (mi->bind == NULL) {
+			pr_debug("%s: false as %d is slave with unmounted master %d\n", __func__, mi->mnt_id,
+				 mi->mnt_master->mnt_id);
 			return false;
+		}
 
-		list_for_each_entry(c, &mi->mnt_master->children, siblings)
-			if (!c->mounted)
+		list_for_each_entry(c, &mi->mnt_master->children, siblings) {
+			if (!c->mounted) {
+				pr_debug("%s: false as %d is slave with unmounted master's children %d\n", __func__,
+					 mi->mnt_id, c->mnt_id);
 				return false;
+			}
+		}
 
-		list_for_each_entry(s, &mi->mnt_master->mnt_share, mnt_share)
-			list_for_each_entry(c, &s->children, siblings)
-				if (!c->mounted)
+		list_for_each_entry(s, &mi->mnt_master->mnt_share, mnt_share) {
+			list_for_each_entry(c, &s->children, siblings) {
+				if (!c->mounted) {
+					pr_debug("%s: false as %d is slave with unmounted children of master's share\n",
+						 __func__, mi->mnt_id);
 					return false;
+				}
+			}
+		}
 	}
 
-	if (!fsroot_mounted(mi) && (mi->bind == NULL && !mi->need_plugin))
+	if (!fsroot_mounted(mi) && (mi->bind == NULL && !mi->need_plugin)) {
+		pr_debug("%s: false as %d is non-root without bind or plugin\n", __func__, mi->mnt_id);
 		return false;
+	}
 
 shared:
 	/* Mount only after all parents of our propagation group mounted */
@@ -2467,8 +2483,11 @@ shared:
 
 		list_for_each_entry(p, &mi->mnt_propagate, mnt_propagate) {
 			BUG_ON(!p->parent);
-			if (!p->parent->mounted)
+			if (!p->parent->mounted) {
+				pr_debug("%s: false as %d has unmounted parent %d of its propagation group\n", __func__,
+					 mi->mnt_id, p->parent->mnt_id);
 				return false;
+			}
 		}
 	}
 
@@ -2515,8 +2534,11 @@ shared:
 
 		/* Check not propagated mounts mounted and cleanup list */
 		list_for_each_entry_safe(p, t, &mi_notprop, mnt_notprop) {
-			if (!p->mounted)
+			if (!p->mounted) {
+				pr_debug("%s: false as %d has unmounted 'anti'-propagation mount %d\n", __func__,
+					 mi->mnt_id, p->mnt_id);
 				can = false;
+			}
 			list_del_init(&p->mnt_notprop);
 		}
 
-- 
2.35.1

