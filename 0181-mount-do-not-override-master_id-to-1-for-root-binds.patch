From 03cb0595a299ffe3e7e55ecb9cc0402277f75e65 Mon Sep 17 00:00:00 2001
From: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
Date: Fri, 14 Jan 2022 14:33:30 +0300
Subject: [PATCH 181/249] mount: do not override master_id to -1 for root binds

There is no point to lose this information, having -1 everywhere in
mount images instead of acutall master id can be confusing.

Note that now need_master is true for bindmounts of root mounts with
same master_id as root mount, so now they are handled with a common
code, we've added can_receive_master_from_root check specially to handle
this case right. Also note that in propagate_mount we no more set ->bind
for this case, this is handled by mnt_ext_slave list related code.

Cherry-picked from Virtuozzo criu:
https://src.openvz.org/projects/OVZ/repos/criu/commits/b3c9dc05e

Stripped only master_id relative part of original patch, add
preparational patches before this one.

Signed-off-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
---
 criu/mount.c | 18 +++++-------------
 1 file changed, 5 insertions(+), 13 deletions(-)

diff --git a/criu/mount.c b/criu/mount.c
index 22c062e36..8d0a17d96 100644
--- a/criu/mount.c
+++ b/criu/mount.c
@@ -1013,7 +1013,7 @@ struct mount_info *mnt_bind_pick(struct mount_info *mi, bool (*pick)(struct moun
 	return NULL;
 }
 
-static int resolve_shared_mounts(struct mount_info *info, int root_master_id)
+static int resolve_shared_mounts(struct mount_info *info)
 {
 	struct mount_info *m, *t;
 
@@ -1026,12 +1026,8 @@ static int resolve_shared_mounts(struct mount_info *info, int root_master_id)
 	for (m = info; m; m = m->next) {
 		bool need_share, need_master;
 
-		/* the root master_id can be ignored, because it's already created */
-		if (root_master_id && root_master_id == m->master_id)
-			m->master_id = -1;
-
 		need_share = m->shared_id && list_empty(&m->mnt_share);
-		need_master = m->master_id > 0;
+		need_master = m->master_id;
 
 		pr_debug("Inspecting sharing on %2d shared_id %d master_id %d (@%s)\n", m->mnt_id, m->shared_id,
 			 m->master_id, m->mountpoint);
@@ -2110,7 +2106,7 @@ skip_parent:
 				continue;
 			if (t->bind)
 				continue;
-			if (t->master_id > 0)
+			if (t->master_id)
 				continue;
 			if (!issubpath(t->root, mi->root))
 				continue;
@@ -3457,7 +3453,7 @@ static int populate_mnt_ns(void)
 	}
 #endif
 
-	if (resolve_shared_mounts(mntinfo, 0))
+	if (resolve_shared_mounts(mntinfo))
 		return -1;
 
 	if (validate_mounts(mntinfo, false))
@@ -3845,7 +3841,6 @@ int mntns_get_root_by_mnt_id(int mnt_id)
 struct collect_mntns_arg {
 	bool need_to_validate;
 	bool for_dump;
-	int root_master_id;
 };
 
 static int collect_mntns(struct ns_id *ns, void *__arg)
@@ -3862,9 +3857,6 @@ static int collect_mntns(struct ns_id *ns, void *__arg)
 
 	mntinfo_add_list(pms);
 
-	if (arg->need_to_validate && ns->id == root_item->ids->mnt_ns_id)
-		arg->root_master_id = ns->mnt.mntinfo_tree->master_id;
-
 	return 0;
 }
 
@@ -3918,7 +3910,7 @@ int collect_mnt_namespaces(bool for_dump)
 	if (arg.need_to_validate) {
 		ret = -1;
 
-		if (resolve_shared_mounts(mntinfo, arg.root_master_id))
+		if (resolve_shared_mounts(mntinfo))
 			goto err;
 		if (validate_mounts(mntinfo, true))
 			goto err;
-- 
2.35.1

