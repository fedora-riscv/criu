From 7d5222dce8fc65def14c935b8a669d38d65c81e0 Mon Sep 17 00:00:00 2001
From: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
Date: Fri, 29 May 2020 10:27:05 +0300
Subject: [PATCH 184/245] mount: prepare is_overmounted as early as possible

Function mnt_is_overmounted is designed to detect if mount is overmounted in
current tree using comparison of mountpoints of neighbour mounts for detection.
We want to get actual overmounts in dumped tree, we don't expect that helper
mounts we add or merging will introduce new overmounts. So let's do overmount
detection earlier before adding helpers.

Set is_overmounted = false for root yard and binfmt helper mounts.

Cherry-picked from Virtuozzo criu:
https://src.openvz.org/projects/OVZ/repos/criu/commits/e98e1456d

Changes: rename set_is_overmounted to prepare_is_overmounted, move it
just after collecting mounts from images to mount tree, handle helper
mounts.

Signed-off-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
---
 criu/include/mount.h |  2 ++
 criu/mount.c         | 31 +++++++++++++++++++++++++++----
 2 files changed, 29 insertions(+), 4 deletions(-)

diff --git a/criu/include/mount.h b/criu/include/mount.h
index 050141058..519a34d2a 100644
--- a/criu/include/mount.h
+++ b/criu/include/mount.h
@@ -184,4 +184,6 @@ extern struct mount_info *mnt_get_external_bind_nodev(struct mount_info *mi);
 
 extern struct mount_info *mnt_bind_pick(struct mount_info *mi,
 					bool (*pick)(struct mount_info *mi, struct mount_info *bind));
+
+extern int mnt_tree_for_each(struct mount_info *start, int (*fn)(struct mount_info *));
 #endif /* __CR_MOUNT_H__ */
diff --git a/criu/mount.c b/criu/mount.c
index 632da6f5c..30872f1ce 100644
--- a/criu/mount.c
+++ b/criu/mount.c
@@ -1347,13 +1347,35 @@ exit:
 	return mi->is_overmounted;
 }
 
-static int set_is_overmounted(struct mount_info *mi)
+static int __set_is_overmounted(struct mount_info *mi)
 {
 	/* coverity[check_return] */
 	mnt_is_overmounted(mi);
 	return 0;
 }
 
+/*
+ * mnt_is_overmounted is intended to detect overmounts in original dumped mount
+ * tree, so we pre-save it just after loading mount tree from images, so that
+ * it does not mess up with any helper mounts or tree changes we can do.
+ */
+static void prepare_is_overmounted(void)
+{
+	struct ns_id *nsid;
+
+	for (nsid = ns_ids; nsid; nsid = nsid->next) {
+		struct mount_info *root;
+
+		if (nsid->nd != &mnt_ns_desc)
+			continue;
+
+		root = nsid->mnt.mntinfo_tree;
+
+		BUG_ON(root->parent);
+		mnt_tree_for_each(root, __set_is_overmounted);
+	}
+}
+
 /*
  * __umount_children_overmounts() assumes that the mountpoint and
  * it's ancestors have no sibling-overmounts, so we can see children
@@ -1649,6 +1671,7 @@ static __maybe_unused struct mount_info *add_cr_time_mount(struct mount_info *ro
 	}
 
 	mi->mnt_bind_is_populated = true;
+	mi->is_overmounted = false;
 	mi->nsid = parent->nsid;
 	mi->parent = parent;
 	mi->parent_mnt_id = parent->mnt_id;
@@ -1893,7 +1916,7 @@ err:
 
 #define MNT_WALK_NONE 0 &&
 
-static int mnt_tree_for_each(struct mount_info *start, int (*fn)(struct mount_info *))
+int mnt_tree_for_each(struct mount_info *start, int (*fn)(struct mount_info *))
 {
 	struct mount_info *tmp;
 	LIST_HEAD(postpone);
@@ -3278,6 +3301,7 @@ int read_mnt_ns_img(void)
 	mntinfo = pms;
 
 	search_bindmounts();
+	prepare_is_overmounted();
 
 	return 0;
 }
@@ -3452,6 +3476,7 @@ static int populate_mnt_ns(void)
 	root_yard_mp->mountpoint = mnt_roots;
 	root_yard_mp->mounted = true;
 	root_yard_mp->mnt_bind_is_populated = true;
+	root_yard_mp->is_overmounted = false;
 	root_yard_mp->mnt_id = HELPER_MNT_ID;
 
 	if (merge_mount_trees(root_yard_mp))
@@ -3472,8 +3497,6 @@ static int populate_mnt_ns(void)
 	if (validate_mounts(mntinfo, false))
 		return -1;
 
-	mnt_tree_for_each(root_yard_mp, set_is_overmounted);
-
 	if (find_remap_mounts(root_yard_mp))
 		return -1;
 
-- 
2.35.1

