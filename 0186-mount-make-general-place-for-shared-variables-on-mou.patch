From a554c2d6d9a652ad32f272e7c2a03eec056220e5 Mon Sep 17 00:00:00 2001
From: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
Date: Tue, 16 Jun 2020 16:19:42 +0300
Subject: [PATCH 186/249] mount: make general place for shared variables on
 mount-info on restore

Put remounted_rw to it. This allows us to easily add some more of such
variables without allocating each one of them separately.

Due to existance of shfree_last shmalloc'ed region can be inherited from
the previous caller so it needs to be explicitly zero initialized.

Fixes: 0a2d380e6 ("ghost/mount: allocate remounted_rw in shmem to get
info from other processes")

Cherry-picked from Virtuozzo criu:
https://src.openvz.org/projects/OVZ/repos/criu/commits/6750e5793

Signed-off-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
---
 criu/include/mount.h |  7 ++++++-
 criu/mount.c         | 13 +++++++------
 2 files changed, 13 insertions(+), 7 deletions(-)

diff --git a/criu/include/mount.h b/criu/include/mount.h
index 519a34d2a..3067e4088 100644
--- a/criu/include/mount.h
+++ b/criu/include/mount.h
@@ -26,6 +26,10 @@ struct ns_id;
  */
 #define REMOUNTED_RW_SERVICE 2
 
+struct rst_mount_info {
+	int remounted_rw;
+};
+
 struct mount_info {
 	int mnt_id;
 	int parent_mnt_id;
@@ -86,7 +90,8 @@ struct mount_info {
 	struct list_head postpone;
 
 	int is_overmounted;
-	int *remounted_rw;
+
+	struct rst_mount_info *rmi;
 
 	void *private; /* associated filesystem data */
 };
diff --git a/criu/mount.c b/criu/mount.c
index 3421ef491..5fdd60cda 100644
--- a/criu/mount.c
+++ b/criu/mount.c
@@ -2955,11 +2955,12 @@ struct mount_info *mnt_entry_alloc(bool rst)
 	new = xzalloc(sizeof(struct mount_info));
 	if (new) {
 		if (rst) {
-			new->remounted_rw = shmalloc(sizeof(int));
-			if (!new->remounted_rw) {
+			new->rmi = shmalloc(sizeof(struct rst_mount_info));
+			if (!new->rmi) {
 				xfree(new);
 				return NULL;
 			}
+			memset(new->rmi, 0, sizeof(struct rst_mount_info));
 		}
 		new->fd = -1;
 		new->is_overmounted = -1;
@@ -4073,9 +4074,9 @@ int try_remount_writable(struct mount_info *mi, bool ns)
 		remounted = REMOUNTED_RW_SERVICE;
 
 	/* All mounts in mntinfo list should have it on restore */
-	BUG_ON(mi->remounted_rw == NULL);
+	BUG_ON(mi->rmi == NULL);
 
-	if (mi->flags & MS_RDONLY && !(*mi->remounted_rw & remounted)) {
+	if (mi->flags & MS_RDONLY && !(mi->rmi->remounted_rw & remounted)) {
 		if (mnt_is_overmounted(mi)) {
 			pr_err("The mount %d is overmounted so paths are invisible\n", mi->mnt_id);
 			return -1;
@@ -4098,7 +4099,7 @@ int try_remount_writable(struct mount_info *mi, bool ns)
 			if (call_helper_process(ns_remount_writable, mi))
 				return -1;
 		}
-		*mi->remounted_rw |= remounted;
+		mi->rmi->remounted_rw |= remounted;
 	}
 
 	return 0;
@@ -4113,7 +4114,7 @@ static int __remount_readonly_mounts(struct ns_id *ns)
 		if (ns && mi->nsid != ns)
 			continue;
 
-		if (!(*mi->remounted_rw & REMOUNTED_RW))
+		if (!(mi->rmi->remounted_rw & REMOUNTED_RW))
 			continue;
 
 		/*
-- 
2.35.1

