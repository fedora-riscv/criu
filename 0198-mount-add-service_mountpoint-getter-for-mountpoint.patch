From 569d5e17f39c8c206c4b20386b101b29a8fee188 Mon Sep 17 00:00:00 2001
From: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
Date: Thu, 28 May 2020 11:14:39 +0300
Subject: [PATCH 198/249] mount: add service_mountpoint getter for ->mountpoint

This getter should be used when we wan't to access the mount on the filesystem.
In next patches we want to be able to change the location of the mount on
restore in service mount namespace, while not changing ->mountpoint string.
All places where we don't want to access the mount but instead want to
determine relations between mounts in the initial mount tree or just print path
should use ns_mountpoint.

This change effectively brings no change of behaviour everything is the same
for now.

Still leave ->mountpoint references for remap, cr_time and initialization which
need to work with exact variable.

Cherry-picked from Virtuozzo criu:
https://src.openvz.org/projects/OVZ/repos/criu/commits/235c761e0

Signed-off-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
---
 criu/autofs.c        |  22 ++++----
 criu/filesystems.c   |   4 +-
 criu/include/mount.h |   2 +
 criu/mount.c         | 121 +++++++++++++++++++++++--------------------
 criu/proc_parse.c    |   4 +-
 criu/tty.c           |   4 +-
 6 files changed, 83 insertions(+), 74 deletions(-)

diff --git a/criu/autofs.c b/criu/autofs.c
index 9d146b92b..c662bea60 100644
--- a/criu/autofs.c
+++ b/criu/autofs.c
@@ -388,7 +388,7 @@ free_str:
  */
 static int access_autofs_mount(struct mount_info *pm)
 {
-	const char *mnt_path = pm->mountpoint + 1;
+	const char *mnt_path = service_mountpoint(pm) + 1;
 	dev_t dev_id = pm->s_dev;
 	int new_pid_ns = -1, old_pid_ns = -1;
 	int old_mnt_ns, old_cwd_fd;
@@ -498,7 +498,7 @@ static int autofs_create_entry(struct mount_info *pm, AutofsEntry *entry)
 			 * options, then we can read them again and dump it.
 			 */
 			if (access_autofs_mount(pm)) {
-				pr_err("failed to access autofs %s\n", pm->mountpoint + 1);
+				pr_err("failed to access autofs %s\n", service_mountpoint(pm) + 1);
 				return -1;
 			}
 			if (parse_options(pm->options, entry, &pipe_ino))
@@ -755,7 +755,7 @@ static int autofs_populate_mount(const struct mount_info *mi, const AutofsEntry
 	if (entry->mode != AUTOFS_MODE_INDIRECT)
 		return 0;
 
-	return autofs_create_dentries(mi, mi->mountpoint);
+	return autofs_create_dentries(mi, service_mountpoint(mi));
 }
 
 static int autofs_post_mount(const char *mnt_path, dev_t mnt_dev, time_t timeout)
@@ -1031,10 +1031,10 @@ int autofs_mount(struct mount_info *mi, const char *source, const char *filesyst
 		goto close_pipe;
 	}
 
-	pr_info("autofs: mounting to %s with options: \"%s\"\n", mi->mountpoint, opts);
+	pr_info("autofs: mounting to %s with options: \"%s\"\n", service_mountpoint(mi), opts);
 
-	if (mount(source, mi->mountpoint, filesystemtype, mountflags, opts) < 0) {
-		pr_perror("Failed to mount autofs to %s", mi->mountpoint);
+	if (mount(source, service_mountpoint(mi), filesystemtype, mountflags, opts) < 0) {
+		pr_perror("Failed to mount autofs to %s", service_mountpoint(mi));
 		goto free_opts;
 	}
 
@@ -1049,8 +1049,8 @@ int autofs_mount(struct mount_info *mi, const char *source, const char *filesyst
 	 * data is not ready yet. So, let's put in on mi->private and copy to
 	 * shared data in autofs_add_mount_info().
 	 */
-	if (stat(mi->mountpoint, &buf) < 0) {
-		pr_perror("Failed to stat %s", mi->mountpoint);
+	if (stat(service_mountpoint(mi), &buf) < 0) {
+		pr_perror("Failed to stat %s", service_mountpoint(mi));
 		goto free_info;
 	}
 	info->mnt_dev = buf.st_dev;
@@ -1061,7 +1061,7 @@ int autofs_mount(struct mount_info *mi, const char *source, const char *filesyst
 		goto free_info;
 
 	/* In case of catatonic mounts all we need as the function call below */
-	ret = autofs_post_mount(mi->mountpoint, buf.st_dev, entry->timeout);
+	ret = autofs_post_mount(service_mountpoint(mi), buf.st_dev, entry->timeout);
 	if (ret < 0)
 		goto free_info;
 
@@ -1084,7 +1084,7 @@ close_pipe:
 free_info:
 	free(info);
 umount:
-	if (umount(mi->mountpoint) < 0)
-		pr_perror("Failed to umount %s", mi->mountpoint);
+	if (umount(service_mountpoint(mi)) < 0)
+		pr_perror("Failed to umount %s", service_mountpoint(mi));
 	goto close_pipe;
 }
diff --git a/criu/filesystems.c b/criu/filesystems.c
index 439735204..890d5d06d 100644
--- a/criu/filesystems.c
+++ b/criu/filesystems.c
@@ -290,7 +290,7 @@ static int binfmt_misc_restore_bme(struct mount_info *mi, BinfmtMiscEntry *bme,
 		goto bad_dump;
 
 	pr_debug("binfmt_misc_pattern=%s\n", buf);
-	ret = write_binfmt_misc_entry(mi->mountpoint, buf, bme);
+	ret = write_binfmt_misc_entry(service_mountpoint(mi), buf, bme);
 
 	return ret;
 
@@ -452,7 +452,7 @@ static int tmpfs_restore(struct mount_info *pm)
 
 	ret = cr_system(img_raw_fd(img), -1, -1, "tar",
 			(char *[]){ "tar", "--extract", "--gzip", "--no-unquote", "--no-wildcards", "--directory",
-				    pm->mountpoint, NULL },
+				    service_mountpoint(pm), NULL },
 			0);
 	close_image(img);
 
diff --git a/criu/include/mount.h b/criu/include/mount.h
index 3067e4088..8eb4ddf9b 100644
--- a/criu/include/mount.h
+++ b/criu/include/mount.h
@@ -191,4 +191,6 @@ extern struct mount_info *mnt_bind_pick(struct mount_info *mi,
 					bool (*pick)(struct mount_info *mi, struct mount_info *bind));
 
 extern int mnt_tree_for_each(struct mount_info *start, int (*fn)(struct mount_info *));
+
+extern char *service_mountpoint(const struct mount_info *mi);
 #endif /* __CR_MOUNT_H__ */
diff --git a/criu/mount.c b/criu/mount.c
index 980288818..bddfe2e7f 100644
--- a/criu/mount.c
+++ b/criu/mount.c
@@ -47,6 +47,11 @@ static struct mount_info *root_yard_mp = NULL;
 
 static LIST_HEAD(delayed_unbindable);
 
+char *service_mountpoint(const struct mount_info *mi)
+{
+	return mi->mountpoint;
+}
+
 int ext_mount_add(char *key, char *val)
 {
 	cleanup_free char *e_str = NULL;
@@ -1664,7 +1669,7 @@ static __maybe_unused struct mount_info *add_cr_time_mount(struct mount_info *ro
 	parent = root;
 	while (1) {
 		list_for_each_entry(t, &parent->children, siblings) {
-			if (strstartswith(mi->mountpoint, t->mountpoint)) {
+			if (strstartswith(service_mountpoint(mi), service_mountpoint(t))) {
 				parent = t;
 				break;
 			}
@@ -1679,7 +1684,8 @@ static __maybe_unused struct mount_info *add_cr_time_mount(struct mount_info *ro
 	mi->parent = parent;
 	mi->parent_mnt_id = parent->mnt_id;
 	list_add(&mi->siblings, &parent->children);
-	pr_info("Add cr-time mountpoint %s with parent %s(%u)\n", mi->mountpoint, parent->mountpoint, parent->mnt_id);
+	pr_info("Add cr-time mountpoint %s with parent %s(%u)\n", service_mountpoint(mi), service_mountpoint(parent),
+		parent->mnt_id);
 	return mi;
 
 err:
@@ -1994,23 +2000,23 @@ static char *resolve_source(struct mount_info *mi)
 
 static int restore_shared_options(struct mount_info *mi, bool private, bool shared, bool slave)
 {
-	pr_debug("%d:%s private %d shared %d slave %d\n", mi->mnt_id, mi->mountpoint, private, shared, slave);
+	pr_debug("%d:%s private %d shared %d slave %d\n", mi->mnt_id, service_mountpoint(mi), private, shared, slave);
 
 	if (mi->flags & MS_UNBINDABLE) {
 		if (shared || slave) {
-			pr_warn("%s has both unbindable and sharing, ignoring unbindable\n", mi->mountpoint);
+			pr_warn("%s has both unbindable and sharing, ignoring unbindable\n", service_mountpoint(mi));
 		} else {
 			if (!mnt_is_overmounted(mi)) {
 				/* Someone may still want to bind from us, let them do it. */
-				pr_debug("Temporary leave unbindable mount %s as private\n", mi->mountpoint);
-				if (mount(NULL, mi->mountpoint, NULL, MS_PRIVATE, NULL)) {
+				pr_debug("Temporary leave unbindable mount %s as private\n", service_mountpoint(mi));
+				if (mount(NULL, service_mountpoint(mi), NULL, MS_PRIVATE, NULL)) {
 					pr_perror("Unable to make %d private", mi->mnt_id);
 					return -1;
 				}
 				list_add(&mi->mnt_unbindable, &delayed_unbindable);
 				return 0;
 			}
-			if (mount(NULL, mi->mountpoint, NULL, MS_UNBINDABLE, NULL)) {
+			if (mount(NULL, service_mountpoint(mi), NULL, MS_UNBINDABLE, NULL)) {
 				pr_perror("Unable to make %d unbindable", mi->mnt_id);
 				return -1;
 			}
@@ -2018,15 +2024,15 @@ static int restore_shared_options(struct mount_info *mi, bool private, bool shar
 		}
 	}
 
-	if (private && mount(NULL, mi->mountpoint, NULL, MS_PRIVATE, NULL)) {
+	if (private && mount(NULL, service_mountpoint(mi), NULL, MS_PRIVATE, NULL)) {
 		pr_perror("Unable to make %d private", mi->mnt_id);
 		return -1;
 	}
-	if (slave && mount(NULL, mi->mountpoint, NULL, MS_SLAVE, NULL)) {
+	if (slave && mount(NULL, service_mountpoint(mi), NULL, MS_SLAVE, NULL)) {
 		pr_perror("Unable to make %d slave", mi->mnt_id);
 		return -1;
 	}
-	if (shared && mount(NULL, mi->mountpoint, NULL, MS_SHARED, NULL)) {
+	if (shared && mount(NULL, service_mountpoint(mi), NULL, MS_SHARED, NULL)) {
 		pr_perror("Unable to make %d shared", mi->mnt_id);
 		return -1;
 	}
@@ -2183,9 +2189,9 @@ static int fetch_rt_stat(struct mount_info *m, const char *where)
 
 static int do_simple_mount(struct mount_info *mi, const char *src, const char *fstype, unsigned long mountflags)
 {
-	int ret = mount(src, mi->mountpoint, fstype, mountflags, mi->options);
+	int ret = mount(src, service_mountpoint(mi), fstype, mountflags, mi->options);
 	if (ret)
-		pr_perror("Unable to mount %s %s (id=%d)", src, mi->mountpoint, mi->mnt_id);
+		pr_perror("Unable to mount %s %s (id=%d)", src, service_mountpoint(mi), mi->mnt_id);
 	return ret;
 }
 
@@ -2250,7 +2256,7 @@ static int do_new_mount(struct mount_info *mi)
 		sflags &= ~MS_RDONLY;
 
 	if (do_mount(mi, src, mnt_fsname(mi), sflags) < 0) {
-		pr_perror("Can't mount at %s", mi->mountpoint);
+		pr_perror("Can't mount at %s", service_mountpoint(mi));
 		return -1;
 	}
 
@@ -2260,21 +2266,21 @@ static int do_new_mount(struct mount_info *mi)
 	if (remount_ro) {
 		int fd;
 
-		fd = open(mi->mountpoint, O_PATH);
+		fd = open(service_mountpoint(mi), O_PATH);
 		if (fd < 0) {
-			pr_perror("Unable to open %s", mi->mountpoint);
+			pr_perror("Unable to open %s", service_mountpoint(mi));
 			return -1;
 		}
 		sflags |= MS_RDONLY | MS_REMOUNT;
 		if (userns_call(apply_sb_flags, 0, &sflags, sizeof(sflags), fd)) {
-			pr_err("Unable to apply mount flags %d for %s\n", mi->sb_flags, mi->mountpoint);
+			pr_err("Unable to apply mount flags %d for %s\n", mi->sb_flags, service_mountpoint(mi));
 			close(fd);
 			return -1;
 		}
 		close(fd);
 	}
 
-	if (mflags && mount(NULL, mi->mountpoint, NULL, MS_REMOUNT | MS_BIND | mflags, NULL)) {
+	if (mflags && mount(NULL, service_mountpoint(mi), NULL, MS_REMOUNT | MS_BIND | mflags, NULL)) {
 		pr_perror("Unable to apply bind-mount options");
 		return -1;
 	}
@@ -2296,8 +2302,8 @@ static int restore_ext_mount(struct mount_info *mi)
 {
 	int ret;
 
-	pr_debug("Restoring external bind mount %s\n", mi->mountpoint);
-	ret = run_plugins(RESTORE_EXT_MOUNT, mi->mnt_id, mi->mountpoint, "/", NULL);
+	pr_debug("Restoring external bind mount %s\n", service_mountpoint(mi));
+	ret = run_plugins(RESTORE_EXT_MOUNT, mi->mnt_id, service_mountpoint(mi), "/", NULL);
 	if (ret)
 		pr_err("Can't restore ext mount (%d)\n", ret);
 	return ret;
@@ -2390,9 +2396,9 @@ static int do_bind_mount(struct mount_info *mi)
 	 */
 	mi->private = mi->bind->private;
 
-	mnt_path = mi->bind->mountpoint;
+	mnt_path = service_mountpoint(mi->bind);
 
-	/* Access a mount by fd if mi->bind->mountpoint is overmounted */
+	/* Access a mount by fd if service_mountpoint(mi->bind) is overmounted */
 	if (mi->bind->fd >= 0) {
 		snprintf(mnt_fd_path, sizeof(mnt_fd_path), "/proc/self/fd/%d", mi->bind->fd);
 		mnt_path = mnt_fd_path;
@@ -2405,14 +2411,14 @@ static int do_bind_mount(struct mount_info *mi)
 	 * The target path may be over-mounted by one of child mounts
 	 * and we need to create a new bind-mount to get access to the path.
 	 */
-	mp_len = strlen(mi->bind->mountpoint);
-	if (mp_len > 1) /* skip a joining / if mi->bind->mountpoint isn't "/" */
+	mp_len = strlen(service_mountpoint(mi->bind));
+	if (mp_len > 1) /* skip a joining / if service_mountpoint(mi->bind) isn't "/" */
 		mp_len++;
 
 	list_for_each_entry(c, &mi->bind->children, siblings) {
 		if (!c->mounted)
 			continue;
-		if (issubpath(cut_root, c->mountpoint + mp_len))
+		if (issubpath(cut_root, service_mountpoint(c) + mp_len))
 			break; /* a source path is overmounted */
 	}
 
@@ -2433,11 +2439,11 @@ skip_overmount_check:
 	snprintf(rpath, sizeof(rpath), "%s/%s", mnt_path, cut_root);
 	root = rpath;
 do_bind:
-	pr_info("\tBind %s to %s\n", root, mi->mountpoint);
+	pr_info("\tBind %s to %s\n", root, service_mountpoint(mi));
 
 	if (unlikely(mi->deleted)) {
-		if (stat(mi->mountpoint, &st)) {
-			pr_perror("Can't fetch stat on %s", mi->mountpoint);
+		if (stat(service_mountpoint(mi), &st)) {
+			pr_perror("Can't fetch stat on %s", service_mountpoint(mi));
 			goto err;
 		}
 
@@ -2459,15 +2465,15 @@ do_bind:
 		}
 	}
 
-	if (mount(root, mi->mountpoint, NULL, MS_BIND | (mi->flags & MS_REC), NULL) < 0) {
-		pr_perror("Can't mount at %s", mi->mountpoint);
+	if (mount(root, service_mountpoint(mi), NULL, MS_BIND | (mi->flags & MS_REC), NULL) < 0) {
+		pr_perror("Can't mount at %s", service_mountpoint(mi));
 		goto err;
 	}
 
 	mflags = mi->flags & (~MS_PROPAGATE);
 	if (!mi->bind || mflags != (mi->bind->flags & (~MS_PROPAGATE)))
-		if (mount(NULL, mi->mountpoint, NULL, MS_BIND | MS_REMOUNT | mflags, NULL)) {
-			pr_perror("Can't mount at %s", mi->mountpoint);
+		if (mount(NULL, service_mountpoint(mi), NULL, MS_BIND | MS_REMOUNT | mflags, NULL)) {
+			pr_perror("Can't mount at %s", service_mountpoint(mi));
 			goto err;
 		}
 
@@ -2649,7 +2655,7 @@ static int do_mount_root(struct mount_info *mi)
 	if (restore_shared_options(mi, !mi->shared_id && !mi->master_id, mi->shared_id, mi->master_id))
 		return -1;
 
-	return fetch_rt_stat(mi, mi->mountpoint);
+	return fetch_rt_stat(mi, service_mountpoint(mi));
 }
 
 static int do_close_one(struct mount_info *mi)
@@ -2660,7 +2666,7 @@ static int do_close_one(struct mount_info *mi)
 
 static int set_unbindable(struct mount_info *mi)
 {
-	if (mount(NULL, mi->mountpoint, NULL, MS_UNBINDABLE, NULL)) {
+	if (mount(NULL, service_mountpoint(mi), NULL, MS_UNBINDABLE, NULL)) {
 		pr_perror("Failed setting unbindable flag on %d", mi->mnt_id);
 		return -1;
 	}
@@ -2681,14 +2687,14 @@ static int do_mount_one(struct mount_info *mi)
 	}
 
 	if ((mi->parent && mi->parent != root_yard_mp) && !strcmp(mi->parent->ns_mountpoint, mi->ns_mountpoint)) {
-		mi->parent->fd = open(mi->parent->mountpoint, O_PATH);
+		mi->parent->fd = open(service_mountpoint(mi->parent), O_PATH);
 		if (mi->parent->fd < 0) {
-			pr_perror("Unable to open %s", mi->mountpoint);
+			pr_perror("Unable to open %s", service_mountpoint(mi));
 			return -1;
 		}
 	}
 
-	pr_debug("\tMounting %s @%s (%d)\n", mi->fstype->name, mi->mountpoint, mi->need_plugin);
+	pr_debug("\tMounting %s %d@%s (%d)\n", mi->fstype->name, mi->mnt_id, service_mountpoint(mi), mi->need_plugin);
 
 	if (rst_mnt_is_root(mi)) {
 		int fd;
@@ -2701,21 +2707,22 @@ static int do_mount_one(struct mount_info *mi)
 
 		/* do_mount_root() is called from populate_mnt_ns() */
 		if (root_ns_mask & CLONE_NEWUSER) {
-			fd = open(mi->mountpoint, O_PATH);
+			fd = open(service_mountpoint(mi), O_PATH);
 			if (fd < 0) {
-				pr_perror("Unable to open %s", mi->mountpoint);
+				pr_perror("Unable to open %s", service_mountpoint(mi));
 				return -1;
 			}
 
 			if (userns_call(mount_root, 0, &flags, sizeof(flags), fd)) {
-				pr_err("Unable to mount %s\n", mi->mountpoint);
+				pr_err("Unable to mount %s\n", service_mountpoint(mi));
 				close(fd);
 				return -1;
 			}
 			close(fd);
 		} else {
-			if (mount(opts.root, mi->mountpoint, NULL, flags, NULL)) {
-				pr_perror("Unable to mount %s %s (id=%d)", opts.root, mi->mountpoint, mi->mnt_id);
+			if (mount(opts.root, service_mountpoint(mi), NULL, flags, NULL)) {
+				pr_perror("Unable to mount %s %s (id=%d)", opts.root, service_mountpoint(mi),
+					  mi->mnt_id);
 				return -1;
 			}
 		}
@@ -2730,7 +2737,7 @@ static int do_mount_one(struct mount_info *mi)
 		ret = do_bind_mount(mi);
 	}
 
-	if (ret == 0 && fetch_rt_stat(mi, mi->mountpoint))
+	if (ret == 0 && fetch_rt_stat(mi, service_mountpoint(mi)))
 		return -1;
 
 	if (ret == 0 && propagate_mount(mi))
@@ -2739,8 +2746,8 @@ static int do_mount_one(struct mount_info *mi)
 	if (mi->fstype->code == FSTYPE__UNSUPPORTED) {
 		struct statfs st;
 
-		if (statfs(mi->mountpoint, &st)) {
-			pr_perror("Unable to statfs %s", mi->mountpoint);
+		if (statfs(service_mountpoint(mi), &st)) {
+			pr_perror("Unable to statfs %s", service_mountpoint(mi));
 			return -1;
 		}
 		if (st.f_type == BTRFS_SUPER_MAGIC)
@@ -2755,17 +2762,17 @@ static int do_umount_one(struct mount_info *mi)
 	if (!mi->parent)
 		return 0;
 
-	if (mount("none", mi->parent->mountpoint, "none", MS_REC | MS_PRIVATE, NULL)) {
-		pr_perror("Can't mark %s as private", mi->parent->mountpoint);
+	if (mount("none", service_mountpoint(mi->parent), "none", MS_REC | MS_PRIVATE, NULL)) {
+		pr_perror("Can't mark %s as private", service_mountpoint(mi->parent));
 		return -1;
 	}
 
-	if (umount(mi->mountpoint)) {
-		pr_perror("Can't umount at %s", mi->mountpoint);
+	if (umount(service_mountpoint(mi))) {
+		pr_perror("Can't umount at %s", service_mountpoint(mi));
 		return -1;
 	}
 
-	pr_info("Umounted at %s\n", mi->mountpoint);
+	pr_info("Umounted at %s\n", service_mountpoint(mi));
 	return 0;
 }
 
@@ -3113,7 +3120,7 @@ static int get_mp_mountpoint(char *mountpoint, struct mount_info *mi, char *root
 
 	mi->ns_mountpoint = mi->mountpoint + root_len;
 
-	pr_debug("\t\tWill mount %d @ %s\n", mi->mnt_id, mi->mountpoint);
+	pr_debug("\t\tWill mount %d @ %s %s\n", mi->mnt_id, service_mountpoint(mi), mi->ns_mountpoint);
 	return 0;
 }
 
@@ -3469,14 +3476,14 @@ static int populate_roots_yard(struct mount_info *cr_time)
 	 * contains mounts which has to be restored separately
 	 */
 	list_for_each_entry(r, &mnt_remap_list, node) {
-		if (mkdirpat(AT_FDCWD, r->mi->mountpoint, 0755)) {
-			pr_perror("Unable to create %s", r->mi->mountpoint);
+		if (mkdirpat(AT_FDCWD, service_mountpoint(r->mi), 0755)) {
+			pr_perror("Unable to create %s", service_mountpoint(r->mi));
 			return -1;
 		}
 	}
 
-	if (cr_time && mkdirpat(AT_FDCWD, cr_time->mountpoint, 0755)) {
-		pr_perror("Unable to create %s", cr_time->mountpoint);
+	if (cr_time && mkdirpat(AT_FDCWD, service_mountpoint(cr_time), 0755)) {
+		pr_perror("Unable to create %s", service_mountpoint(cr_time));
 		return -1;
 	}
 
@@ -4093,11 +4100,11 @@ int try_remount_writable(struct mount_info *mi, bool ns)
 			return -1;
 		}
 
-		pr_info("Remount %d:%s writable\n", mi->mnt_id, mi->mountpoint);
+		pr_info("Remount %d:%s writable\n", mi->mnt_id, service_mountpoint(mi));
 		if (!ns) {
-			if (mount(NULL, mi->mountpoint, NULL,
+			if (mount(NULL, service_mountpoint(mi), NULL,
 				  MS_REMOUNT | MS_BIND | (mi->flags & ~(MS_PROPAGATE | MS_RDONLY)), NULL) == -1) {
-				pr_perror("Failed to remount %d:%s writable", mi->mnt_id, mi->mountpoint);
+				pr_perror("Failed to remount %d:%s writable", mi->mnt_id, service_mountpoint(mi));
 				return -1;
 			}
 		} else {
diff --git a/criu/proc_parse.c b/criu/proc_parse.c
index 0fbc440a2..338b42f4b 100644
--- a/criu/proc_parse.c
+++ b/criu/proc_parse.c
@@ -1603,14 +1603,14 @@ struct mount_info *parse_mountinfo(pid_t pid, struct ns_id *nsid, bool for_dump)
 		if (new->fstype->parse) {
 			ret = new->fstype->parse(new);
 			if (ret < 0) {
-				pr_err("Failed to parse FS specific data on %s\n", new->mountpoint);
+				pr_err("Failed to parse FS specific data on %s\n", service_mountpoint(new));
 				mnt_entry_free(new);
 				new = NULL;
 				goto end;
 			}
 
 			if (ret > 0) {
-				pr_info("\tskipping fs mounted at %s\n", new->mountpoint + 1);
+				pr_info("\tskipping fs mounted at %s\n", service_mountpoint(new) + 1);
 				mnt_entry_free(new);
 				new = NULL;
 				ret = 0;
diff --git a/criu/tty.c b/criu/tty.c
index 1462193c5..0430dbff7 100644
--- a/criu/tty.c
+++ b/criu/tty.c
@@ -2406,9 +2406,9 @@ int devpts_restore(struct mount_info *pm)
 	struct mount_info *bm;
 	int dfd, exit_code = -1;
 
-	dfd = open(pm->mountpoint, O_RDONLY);
+	dfd = open(service_mountpoint(pm), O_RDONLY);
 	if (dfd < 0) {
-		pr_perror("Unable to open %s", pm->mountpoint);
+		pr_perror("Unable to open %s", service_mountpoint(pm));
 		return -1;
 	}
 
-- 
2.35.1

