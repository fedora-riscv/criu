From 45a06d6b9b34f0484ca3dad560e53914db05fff6 Mon Sep 17 00:00:00 2001
From: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
Date: Thu, 14 May 2020 14:11:47 +0300
Subject: [PATCH 200/249] files-reg: teach create_ghost to work with mount-v2

While mounts-v2 would mount all mounts plain without tree in service
mntns we can't just use path relative to mntns to find remap. Make it
mount related, it is also compatible with current mount engine.

Also handle no-mntns case separately in nomntns_create_ghost.

Cherry-picked from Virtuozzo criu:
https://src.openvz.org/projects/OVZ/repos/criu/commits/9cdf0b3e4

Changes: make gf->remap.rpath always relative else we get:
Error (criu/files-reg.c:779): Couldn't unlink remap
/tmp/.criu.mntns.BCurDL/13-0000000000 /zdtm/static/cwd02.test:
No such file or directory

Signed-off-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
---
 criu/files-reg.c | 65 +++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 50 insertions(+), 15 deletions(-)

diff --git a/criu/files-reg.c b/criu/files-reg.c
index 309ecf77c..66e2c2c39 100644
--- a/criu/files-reg.c
+++ b/criu/files-reg.c
@@ -53,6 +53,7 @@
 
 #include "files-reg.h"
 #include "plugin.h"
+#include "string.h"
 
 int setfsuid(uid_t fsuid);
 int setfsgid(gid_t fsuid);
@@ -401,40 +402,74 @@ err:
 	return ret;
 }
 
+static int nomntns_create_ghost(struct ghost_file *gf, GhostFileEntry *gfe, struct cr_img *img)
+{
+	char path[PATH_MAX];
+
+	snprintf(path, sizeof(path), "/%s", gf->remap.rpath);
+
+	if (create_ghost_dentry(path, gfe, img))
+		return -1;
+
+	if (ghost_apply_metadata(path, gfe))
+		return -1;
+
+	strlcpy(gf->remap.rpath, path + 1, PATH_MAX);
+	pr_debug("Remap rpath is %s\n", gf->remap.rpath);
+	return 0;
+}
+
 static int create_ghost(struct ghost_file *gf, GhostFileEntry *gfe, struct cr_img *img)
 {
 	struct mount_info *mi;
-	char path[PATH_MAX];
-	int ret, root_len;
+	char path[PATH_MAX], *rel_path, *rel_mp;
 
-	root_len = ret = rst_get_mnt_root(gf->remap.rmnt_id, path, sizeof(path));
-	if (ret < 0) {
+	if (!(root_ns_mask & CLONE_NEWNS))
+		return nomntns_create_ghost(gf, gfe, img);
+
+	mi = lookup_mnt_id(gf->remap.rmnt_id);
+	if (!mi) {
 		pr_err("The %d mount is not found for ghost\n", gf->remap.rmnt_id);
 		return -1;
 	}
 
-	/* Add a '/' only if we have no at the end */
-	if (path[root_len - 1] != '/') {
-		path[root_len++] = '/';
-		path[root_len] = '\0';
+	/* Get path relative to mountpoint from path relative to mntns */
+	rel_path = get_relative_path(gf->remap.rpath, mi->ns_mountpoint);
+	if (!rel_path) {
+		pr_err("Can't get path %s relative to %s\n", gf->remap.rpath, mi->ns_mountpoint);
+		return -1;
 	}
 
-	snprintf(path + root_len, sizeof(path) - root_len, "%s", gf->remap.rpath);
-	ret = -1;
+	snprintf(path, sizeof(path), "%s%s%s", service_mountpoint(mi), rel_path[0] ? "/" : "", rel_path);
+	pr_debug("Trying to create ghost on path %s\n", path);
 
-	mi = lookup_mnt_id(gf->remap.rmnt_id);
 	/* We get here while in service mntns */
-	if (mi && try_remount_writable(mi, false))
+	if (try_remount_writable(mi, false))
 		return -1;
 
-	ret = create_ghost_dentry(path, gfe, img);
-	if (ret)
+	if (create_ghost_dentry(path, gfe, img))
 		return -1;
 
 	if (ghost_apply_metadata(path, gfe))
 		return -1;
 
-	strcpy(gf->remap.rpath, path + root_len);
+	/*
+	 * Convert the path back to mntns relative, as create_ghost_dentry
+	 * might have changed it.
+	 */
+	rel_path = get_relative_path(path, service_mountpoint(mi));
+	if (!rel_path) {
+		pr_err("Can't get path %s relative to %s\n", path, service_mountpoint(mi));
+		return -1;
+	}
+
+	rel_mp = get_relative_path(mi->ns_mountpoint, "/");
+	if (!rel_mp) {
+		pr_err("Can't get path %s relative to %s\n", mi->ns_mountpoint, "/");
+		return -1;
+	}
+
+	snprintf(gf->remap.rpath, PATH_MAX, "%s%s%s", rel_mp, (rel_mp[0] && rel_path[0]) ? "/" : "", rel_path);
 	pr_debug("Remap rpath is %s\n", gf->remap.rpath);
 	return 0;
 }
-- 
2.35.1

