From 8444d7085e64d63d0b08b52947affb6361a865a6 Mon Sep 17 00:00:00 2001
From: Alexander Mikhalitsyn <alexander.mikhalitsyn@virtuozzo.com>
Date: Fri, 24 Dec 2021 18:57:54 +0300
Subject: [PATCH 241/249] clone-noasan: unregister rseq at the thread start for
 new glibc

Fresh glibc does rseq registration by default during start_thread().
[ see https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=95e114a0919d844d8fe07839cb6538b7f5ee920e ]

This cause process crashes during memory restore procedure, because
memory which corresponds to the struct rseq will be overwritten.

See also
("nptl: Add public rseq symbols and <sys/rseq.h>")
https://sourceware.org/git?p=glibc.git;a=commit;h=c901c3e764d7c7079f006b4e21e877d5036eb4f5
("nptl: Add <thread_pointer.h> for defining __thread_pointer")
https://sourceware.org/git?p=glibc.git;a=commit;h=8dbeb0561eeb876f557ac9eef5721912ec074ea5

Signed-off-by: Alexander Mikhalitsyn <alexander.mikhalitsyn@virtuozzo.com>
---
 criu/clone-noasan.c         | 21 ++++++++++++++++++++-
 criu/cr-restore.c           |  4 ++++
 criu/include/clone-noasan.h | 14 ++++++++++++++
 criu/include/linux/rseq.h   |  9 +++++++++
 4 files changed, 47 insertions(+), 1 deletion(-)

diff --git a/criu/clone-noasan.c b/criu/clone-noasan.c
index d657ea2e8..6d2170dfb 100644
--- a/criu/clone-noasan.c
+++ b/criu/clone-noasan.c
@@ -9,6 +9,8 @@
 #include "log.h"
 #include "common/bug.h"
 
+#include "clone-noasan.h"
+
 /*
  * ASan doesn't play nicely with clone if we use current stack for
  * child task. ASan puts local variables on the fake stack
@@ -34,16 +36,33 @@
  *	... wait for process to finish ...
  *	unlock_last_pid
  */
+
+struct call_fn_args {
+	int (*fn)(void *);
+	void *arg;
+};
+
+int call_fn(void *arg)
+{
+	struct call_fn_args *cargs = arg;
+	unregister_glibc_rseq();
+	return cargs->fn(cargs->arg);
+}
+
 int clone_noasan(int (*fn)(void *), int flags, void *arg)
 {
 	void *stack_ptr = (void *)round_down((unsigned long)&stack_ptr - 1024, 16);
+	struct call_fn_args fn_args = {
+		.fn = fn,
+		.arg = arg,
+	};
 
 	BUG_ON((flags & CLONE_VM) && !(flags & CLONE_VFORK));
 	/*
 	 * Reserve some bytes for clone() internal needs
 	 * and use as stack the address above this area.
 	 */
-	return clone(fn, stack_ptr, flags, arg);
+	return clone(call_fn, stack_ptr, flags, (void *)&fn_args);
 }
 
 int clone3_with_pid_noasan(int (*fn)(void *), void *arg, int flags, int exit_signal, pid_t pid)
diff --git a/criu/cr-restore.c b/criu/cr-restore.c
index 8bfa3ef8c..b2ddc8db0 100644
--- a/criu/cr-restore.c
+++ b/criu/cr-restore.c
@@ -1424,6 +1424,10 @@ static inline int fork_with_pid(struct pstree_item *item)
 		}
 	}
 
+	/* disable rseq to prevent it's inheritance */
+	if (item == root_item)
+		unregister_glibc_rseq();
+
 	if (kdat.has_clone3_set_tid) {
 		ret = clone3_with_pid_noasan(restore_task_with_children, &ca,
 					     (ca.clone_flags & ~(CLONE_NEWNET | CLONE_NEWCGROUP | CLONE_NEWTIME)),
diff --git a/criu/include/clone-noasan.h b/criu/include/clone-noasan.h
index aff773296..6d6e51259 100644
--- a/criu/include/clone-noasan.h
+++ b/criu/include/clone-noasan.h
@@ -1,6 +1,20 @@
 #ifndef __CR_CLONE_NOASAN_H__
 #define __CR_CLONE_NOASAN_H__
 
+#include "linux/rseq.h"
+
+#if defined(RSEQ_SIG)
+static inline void unregister_glibc_rseq(void)
+{
+	/* unregister rseq */
+	syscall(__NR_rseq, (void *)((char *)__criu_thread_pointer() + __rseq_offset), __rseq_size, 1, RSEQ_SIG);
+}
+#else
+static inline void unregister_glibc_rseq(void)
+{
+}
+#endif
+
 int clone_noasan(int (*fn)(void *), int flags, void *arg);
 int clone3_with_pid_noasan(int (*fn)(void *), void *arg, int flags, int exit_signal, pid_t pid);
 
diff --git a/criu/include/linux/rseq.h b/criu/include/linux/rseq.h
index b227aefdf..a47876e66 100644
--- a/criu/include/linux/rseq.h
+++ b/criu/include/linux/rseq.h
@@ -2,6 +2,14 @@
 #ifndef _UAPI_LINUX_RSEQ_H
 #define _UAPI_LINUX_RSEQ_H
 
+#ifdef __has_include
+#if __has_include("sys/rseq.h")
+#include <sys/rseq.h>
+#include "asm/thread_pointer.h"
+#endif
+#endif
+
+#ifndef __GLIBC_HAVE_KERNEL_RSEQ
 /*
  * linux/rseq.h
  *
@@ -49,6 +57,7 @@ struct rseq_cs {
 	__u64 post_commit_offset;
 	__u64 abort_ip;
 } __attribute__((aligned(4 * sizeof(__u64))));
+#endif /* __GLIBC_HAVE_KERNEL_RSEQ */
 
 /*
  * We have to have our own copy of struct rseq definition because
-- 
2.35.1

