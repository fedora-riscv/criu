From patchwork Mon Jul  9 06:28:26 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [1/2] Fix building with 4.18
From: Adrian Reber <adrian@lisas.de>
X-Patchwork-Id: 8849
Message-Id: <1531117707-8173-2-git-send-email-adrian@lisas.de>
To: <criu@openvz.org>, Andrei Vagin <avagin@virtuozzo.com>
Cc: Adrian Reber <areber@redhat.com>
Date: Mon, 9 Jul 2018 06:28:26 +0000

From: Adrian Reber <areber@redhat.com>

Building CRIU against 4.18 fails with multiple re-definition errors.
This has been reported upstream
 https://lore.kernel.org/lkml/20180704142116.GM17048@lisas.de/
but there has not been any answer yet. This tries to workaround those
compile errors by pulling the required aio defines directly into CRIU.

Signed-off-by: Adrian Reber <areber@redhat.com>
---
 criu/cr-check.c          |  2 +-
 criu/include/aio.h       | 73 ++++++++++++++++++++++++++++++++++++++++++++++-
 criu/pie/restorer.c      |  1 -
 test/zdtm/static/aio01.c | 74 ++++++++++++++++++++++++++++++++++++++++++++++--
 4 files changed, 145 insertions(+), 5 deletions(-)

diff --git a/criu/cr-check.c b/criu/cr-check.c
index d3393c4..fc53afb 100644
--- a/criu/cr-check.c
+++ b/criu/cr-check.c
@@ -22,7 +22,6 @@
 #include <sys/prctl.h>
 #include <sched.h>
 #include <sys/mount.h>
-#include <linux/aio_abi.h>
 
 #include "../soccr/soccr.h"
 
@@ -51,6 +50,7 @@
 #include "net.h"
 #include "restorer.h"
 #include "uffd.h"
+#include "aio.h"
 
 static char *feature_name(int (*func)());
 
diff --git a/criu/include/aio.h b/criu/include/aio.h
index 9a58089..a749c47 100644
--- a/criu/include/aio.h
+++ b/criu/include/aio.h
@@ -1,7 +1,6 @@
 #ifndef __CR_AIO_H__
 #define __CR_AIO_H__
 
-#include <linux/aio_abi.h>
 #include "images/mm.pb-c.h"
 unsigned int aio_estimate_nr_reqs(unsigned int size);
 int dump_aio_ring(MmEntry *mme, struct vma_area *vma);
@@ -12,6 +11,78 @@ unsigned long aio_rings_args_size(struct vm_area_list *);
 struct task_restore_args;
 int prepare_aios(struct pstree_item *t, struct task_restore_args *ta);
 
+/* copied from linux/fs.h */
+typedef int __bitwise __kernel_rwf_t;
+
+/* copied from linux/aio_abi.h */
+#ifndef COMPEL_SYSCALL_TYPES_H__
+/* The ifndef is needed to avoid a clang compiler error */
+typedef __kernel_ulong_t aio_context_t;
+#endif
+
+enum {
+	IOCB_CMD_PREAD = 0,
+	IOCB_CMD_PWRITE = 1,
+	IOCB_CMD_FSYNC = 2,
+	IOCB_CMD_FDSYNC = 3,
+	/* These two are experimental.
+	 * IOCB_CMD_PREADX = 4,
+	 * IOCB_CMD_POLL = 5,
+	 */
+	IOCB_CMD_NOOP = 6,
+	IOCB_CMD_PREADV = 7,
+	IOCB_CMD_PWRITEV = 8,
+};
+/* read() from /dev/aio returns these structures. */
+struct io_event {
+	__u64		data;		/* the data field from the iocb */
+	__u64		obj;		/* what iocb this event came from */
+	__s64		res;		/* result code for this event */
+	__s64		res2;		/* secondary result */
+};
+
+/*
+ * we always use a 64bit off_t when communicating
+ * with userland.  its up to libraries to do the
+ * proper padding and aio_error abstraction
+ */
+
+struct iocb {
+	/* these are internal to the kernel/libc. */
+	__u64	aio_data;	/* data to be returned in event's data */
+
+#if defined(__BYTE_ORDER) ? __BYTE_ORDER == __LITTLE_ENDIAN : defined(__LITTLE_ENDIAN)
+	__u32	aio_key;	/* the kernel sets aio_key to the req # */
+	__kernel_rwf_t aio_rw_flags;	/* RWF_* flags */
+#elif defined(__BYTE_ORDER) ? __BYTE_ORDER == __BIG_ENDIAN : defined(__BIG_ENDIAN)
+	__kernel_rwf_t aio_rw_flags;	/* RWF_* flags */
+	__u32	aio_key;	/* the kernel sets aio_key to the req # */
+#else
+#error edit for your odd byteorder.
+#endif
+
+	/* common fields */
+	__u16	aio_lio_opcode;	/* see IOCB_CMD_ above */
+	__s16	aio_reqprio;
+	__u32	aio_fildes;
+
+	__u64	aio_buf;
+	__u64	aio_nbytes;
+	__s64	aio_offset;
+
+	/* extra parameters */
+	__u64	aio_reserved2;	/* TODO: use this for a (struct sigevent *) */
+
+	/* flags for the "struct iocb" */
+	__u32	aio_flags;
+
+	/*
+	 * if the IOCB_FLAG_RESFD flag of "aio_flags" is set, this is an
+	 * eventfd to signal AIO readiness to
+	 */
+	__u32	aio_resfd;
+}; /* 64 bytes */
+
 struct aio_ring {
 	unsigned        id;     /* kernel internal index number */
 	unsigned        nr;     /* number of io_events */
diff --git a/criu/pie/restorer.c b/criu/pie/restorer.c
index 9b7f6dd..f100213 100644
--- a/criu/pie/restorer.c
+++ b/criu/pie/restorer.c
@@ -3,7 +3,6 @@
 
 #include <linux/securebits.h>
 #include <linux/capability.h>
-#include <linux/aio_abi.h>
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <sys/file.h>
diff --git a/test/zdtm/static/aio01.c b/test/zdtm/static/aio01.c
index f84fd35..4ad29a7 100644
--- a/test/zdtm/static/aio01.c
+++ b/test/zdtm/static/aio01.c
@@ -1,6 +1,5 @@
-#include <linux/aio_abi.h>
+#include <linux/types.h>
 #include <sys/syscall.h>
-#include <sys/types.h>
 #include <sys/stat.h>
 #include <string.h>
 #include <stdlib.h>
@@ -13,6 +12,77 @@
 const char *test_doc	= "Check head and tail restore correct";
 const char *test_author	= "Kirill Tkhai <ktkhai@virtuozzo.com>";
 
+/* copied from linux/fs.h */
+typedef int __bitwise __kernel_rwf_t;
+
+/* copied from linux/aio_abi.h */
+#ifndef COMPEL_SYSCALL_TYPES_H__
+typedef __kernel_ulong_t aio_context_t;
+#endif
+
+enum {
+	IOCB_CMD_PREAD = 0,
+	IOCB_CMD_PWRITE = 1,
+	IOCB_CMD_FSYNC = 2,
+	IOCB_CMD_FDSYNC = 3,
+	/* These two are experimental.
+	 * IOCB_CMD_PREADX = 4,
+	 * IOCB_CMD_POLL = 5,
+	 */
+	IOCB_CMD_NOOP = 6,
+	IOCB_CMD_PREADV = 7,
+	IOCB_CMD_PWRITEV = 8,
+};
+/* read() from /dev/aio returns these structures. */
+struct io_event {
+	__u64		data;		/* the data field from the iocb */
+	__u64		obj;		/* what iocb this event came from */
+	__s64		res;		/* result code for this event */
+	__s64		res2;		/* secondary result */
+};
+
+/*
+ * we always use a 64bit off_t when communicating
+ * with userland.  its up to libraries to do the
+ * proper padding and aio_error abstraction
+ */
+
+struct iocb {
+	/* these are internal to the kernel/libc. */
+	__u64	aio_data;	/* data to be returned in event's data */
+
+#if defined(__BYTE_ORDER) ? __BYTE_ORDER == __LITTLE_ENDIAN : defined(__LITTLE_ENDIAN)
+	__u32	aio_key;	/* the kernel sets aio_key to the req # */
+	__kernel_rwf_t aio_rw_flags;	/* RWF_* flags */
+#elif defined(__BYTE_ORDER) ? __BYTE_ORDER == __BIG_ENDIAN : defined(__BIG_ENDIAN)
+	__kernel_rwf_t aio_rw_flags;	/* RWF_* flags */
+	__u32	aio_key;	/* the kernel sets aio_key to the req # */
+#else
+#error edit for your odd byteorder.
+#endif
+
+	/* common fields */
+	__u16	aio_lio_opcode;	/* see IOCB_CMD_ above */
+	__s16	aio_reqprio;
+	__u32	aio_fildes;
+
+	__u64	aio_buf;
+	__u64	aio_nbytes;
+	__s64	aio_offset;
+
+	/* extra parameters */
+	__u64	aio_reserved2;	/* TODO: use this for a (struct sigevent *) */
+
+	/* flags for the "struct iocb" */
+	__u32	aio_flags;
+
+	/*
+	 * if the IOCB_FLAG_RESFD flag of "aio_flags" is set, this is an
+	 * eventfd to signal AIO readiness to
+	 */
+	__u32	aio_resfd;
+}; /* 64 bytes */
+
 struct aio_ring {
 	unsigned	id;     /* kernel internal index number */
 	unsigned	nr;     /* number of io_events */
